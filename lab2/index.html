
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://syssec25/lab2/">
      
      
        <link rel="prev" href="../lab1/">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.5">
    
    
      
        <title>Lab 2 - 浙江大学25年春夏系统安全实验</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#linux-jop" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="浙江大学25年春夏系统安全实验" class="md-header__button md-logo" aria-label="浙江大学25年春夏系统安全实验" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            浙江大学25年春夏系统安全实验
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Lab 2
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/syssec25/syssec25" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    syssec25/syssec25
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="浙江大学25年春夏系统安全实验" class="md-nav__button md-logo" aria-label="浙江大学25年春夏系统安全实验" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    浙江大学25年春夏系统安全实验
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/syssec25/syssec25" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    syssec25/syssec25
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab 1
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Lab 2
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Lab 2
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1 实验目的
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2 实验内容
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3 实验环境
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4 前置知识
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4 前置知识">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-uaf" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 UAF漏洞原理与利用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-linux-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 Linux slab 内存管理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.2 Linux slab 内存管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2.1 什么是 slab ？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2.2 slab分配机制
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-linux" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 Linux 设备及设备驱动
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.3 Linux 设备及设备驱动">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431-devptmx-tty_struct" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.1 /dev/ptmx 伪终端和 tty_struct 结构的利用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432-ioctl" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.2 利用 ioctl 控制寄存器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-jop" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 JOP 基础
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-cred-root" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 利用 cred 结构体获取 root 权限
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.5 利用 cred 结构体获取 root 权限">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-struct-cred" class="md-nav__link">
    <span class="md-ellipsis">
      4.5.1 struct cred的作用
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5 实验介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5 实验介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 实验环境搭建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-zjudev" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 zjudev接口
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-uaf" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 UAF漏洞介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54-struct" class="md-nav__link">
    <span class="md-ellipsis">
      5.4 struct结构介绍
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    <span class="md-ellipsis">
      6 实验任务
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6 实验任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-task1" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Task1：设备接口的使用。
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-task2root-shell" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 Task2：简单获取root shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-task3gadget-root-shell" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Task3：gadget 获取 root shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-task4-cfi" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Task4: 内核 CFI 保护
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    <span class="md-ellipsis">
      7. 实验提交
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1 实验目的
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2 实验内容
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3 实验环境
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4 前置知识
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4 前置知识">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-uaf" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 UAF漏洞原理与利用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-linux-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 Linux slab 内存管理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.2 Linux slab 内存管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2.1 什么是 slab ？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422-slab" class="md-nav__link">
    <span class="md-ellipsis">
      4.2.2 slab分配机制
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-linux" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 Linux 设备及设备驱动
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.3 Linux 设备及设备驱动">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431-devptmx-tty_struct" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.1 /dev/ptmx 伪终端和 tty_struct 结构的利用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432-ioctl" class="md-nav__link">
    <span class="md-ellipsis">
      4.3.2 利用 ioctl 控制寄存器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-jop" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 JOP 基础
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-cred-root" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 利用 cred 结构体获取 root 权限
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4.5 利用 cred 结构体获取 root 权限">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-struct-cred" class="md-nav__link">
    <span class="md-ellipsis">
      4.5.1 struct cred的作用
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5 实验介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5 实验介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 实验环境搭建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-zjudev" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 zjudev接口
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-uaf" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 UAF漏洞介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54-struct" class="md-nav__link">
    <span class="md-ellipsis">
      5.4 struct结构介绍
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    <span class="md-ellipsis">
      6 实验任务
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6 实验任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-task1" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Task1：设备接口的使用。
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-task2root-shell" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 Task2：简单获取root shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-task3gadget-root-shell" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Task3：gadget 获取 root shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-task4-cfi" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Task4: 内核 CFI 保护
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    <span class="md-ellipsis">
      7. 实验提交
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="linux-jop">Linux内核漏洞攻防 - JOP攻击与防护</h1>
<h2 id="1">1 实验目的</h2>
<p>了解 UAF ( Use-After-Free ) 类型的漏洞以及 JOP ( Jump-oriented programming ) 攻击原理，并在此基础上，通过现有的 UAF 漏洞和 JOP 编程，实现获取 Linux 内核的 root 权限的 PoC (Proof of Concept)，并读取一个只有 root 权限下可读的文件，获取 flag。</p>
<h2 id="2">2 实验内容</h2>
<p>1） 利用 gdb 调试内核，获取内核关键函数和 gadget 的地址。</p>
<p>2） 了解 Linux 设备提供的接口和其调用逻辑，并尝试使用 Linux 设备接口进行基础编程，了解 Linux 如何利用系统调用的方式触发内核设备中相应的函数。</p>
<p>3） 理解 UAF 漏洞原理，以及漏洞的利用方式；使用 gdb-multiarch 对所提供的未压缩的内核( vmlinux 文件)进行调试，查找设备 UAF 漏洞所在的位置及触发条件，获取内核 <code>tty_struct</code> 结构体的内容，并利用设备接口控制该结构体的内容，为 root 内核做准备。</p>
<p>4） 了解 JOP 攻击的原理，尝试利用设备接口触发 UAF 漏洞，并挟持控制流，通过 JOP 攻击绕过 PXN 机制，获取内核的 root 权限。</p>
<p>5） 利用提供的 gadget 片段，构造 JOP 攻击跳转链，获取 root 权限的 shell。</p>
<h2 id="3">3 实验环境</h2>
<ul>
<li>实验所需工具：</li>
<li>Linux kernel 5.15</li>
<li>QEMU 模拟器 （qemu-system-aarch64）</li>
<li>gdb-multiarch 多架构调试工具调试 kernel</li>
<li>gdb 调试工具调试用户态程序</li>
<li>实验提供内容：</li>
<li>QEMUrootfs 文件（其内部包含了 gdb，vim 等工具）</li>
<li>QEMU 运行脚本（ qemu.sh ）</li>
<li>vmlinux 内核镜像(用于 gdb-multiarch 调试)</li>
</ul>
<h2 id="4">4 前置知识</h2>
<h3 id="41-uaf">4.1 UAF漏洞原理与利用</h3>
<p>Use-After-Free，即当一块内存被释放之后被再次使用，但是这种使用会分为几种情况：</p>
<ul>
<li>内存块被释放之后，对应的指针被设置成 NULL，然后程序使用空指针导致的<strong>程序崩溃</strong>(一般会报指针解引用错误)。</li>
<li>内存块被释放之后，对应指针没有被设置成 NULL，然后在使用了这个指针之前，没有对这块内存进行修改，<strong>程序很可能能够正常运转</strong>。</li>
<li>内存块被释放之后，对应指针没有被设置成 NULL，且在使用该指针之前有代码对这块内存进行了修改，那么程序再次使用这块内存，<strong>会导致一些奇怪的问题</strong>，比如访问了可能不属于该进程的内存块(由于释放后会被内核分配给别的进程)，甚至通过该指针对这块内存进行修改，然后导致控制流的跳转等。</li>
</ul>
<p>我们一般所说的UAF漏洞指的都是后面两种，释放后没有被设置为 NULL 的内存指针被称为悬挂指针 ( dangling pointer)。</p>
<p>为了更好的理解 UAF，可以先看一段简单的 demo：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">name</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">myname</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">NAME</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">myprint</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printmyname</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;call print my name, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">NAME</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">NAME</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">name</span><span class="p">));</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myprint</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">myname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I can also use it&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="s">&quot;this is my function&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// free without modify</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="s">&quot;I can also use it&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// free with modify</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printmyname</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="s">&quot;this is my function&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// set NULL</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// printf(&quot;this pogram will crash...\n&quot;);</span>
<span class="w">    </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="s">&quot;can not be printed...&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>可以看到该段代码将一个 free 过后的指针继续使用，这也是前述所讲的 UAF 的基本原理。</p>
<p>再来看一段简单的 hello world 程序：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">;</span>
<span class="w">    </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span><span class="w">   </span><span class="c1">//指针p0申请内存；</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;p0 Addr: %p, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p0</span><span class="p">);</span><span class="w">      </span><span class="c1">//打印其地址与值；</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span><span class="w">                               </span><span class="c1">//释放p0；</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span>
<span class="w">    </span><span class="n">p1</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="s">&quot;world&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;p1 Addr: %p, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p0</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>该段程序先通过 malloc 分配了16字节大小的堆上内存块，随后讲该内存块 free，之后又利用 malloc 分配了一块同样大小的内存块。然后我们看一下程序运行结果：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>user@user-Super-Server:~/Desktop/play$<span class="w"> </span>gcc<span class="w"> </span>test.c<span class="w"> </span>
user@user-Super-Server:~/Desktop/play$<span class="w"> </span>./a.out<span class="w"> </span>
p0<span class="w"> </span>Addr:0x5605b5dde2a0,hello
p1<span class="w"> </span>Addr:0x5605b5dde2a0,world
</code></pre></div></td></tr></table></div>
<p>可以发现在堆上分配同样大小的内存时候，第二次分配的地址与第一次分配的地址是一样的，都是 <code>0x5605b5dde2a0</code>。</p>
<blockquote>
<p>Question 1：为什么会这样？为什么两次分配的内存块地址会一样？</p>
<p>提示：堆上内存分配算法，注意glibc 2.26前后的不同，注意用户态与内核态的不同</p>
</blockquote>
<p>由此我们便可以知道 UAF 的利用过程：</p>
<ul>
<li>内存中存在一个空悬指针指向一块攻击者可控的内存。随后将该内存释放，但是不将指针置空，故攻击者仍然可以利用指针控制这块内存的内容。</li>
<li>别的进程或内核通过 malloc/kmalloc 申请了一块同样大小的内存块，会将攻击者可控的这块内存分配出去。</li>
<li>由于这块内存内容攻击者可控，就可以利用该块内存实施攻击手段，包括劫持控制流，泄露数据等，最终达到获取 root 权限的目的。</li>
</ul>
<h3 id="42-linux-slab">4.2 Linux slab 内存管理</h3>
<h4 id="421-slab">4.2.1 什么是 slab ？</h4>
<p>slab 是 Linux 内核的内存管理组件，它用于给 Linux 内核中的对象分配内存，所谓对象就是 Linux 内部的数据结构（task_struct，tty_struct 等）。</p>
<h4 id="422-slab">4.2.2 slab分配机制</h4>
<p>当在内核中调用 kmalloc 时（其功能类似用户空间的malloc，分配一段给定大小的内存），会通过 slab 分配特定的大小的内存块。而 slab 对于内存块具有缓存机制，假设内核中有如下的控制流：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="c1">// do something</span>
<span class="n">kfree</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"> </span>
</code></pre></div></td></tr></table></div>
<p>即内核先通过第一行代码分配了一块 BUF_SIZE 大小的内存块，并将内存块地址赋给指针 a，随后释放了指针 a 所指向的内存块，slab分配器会将其放入一个 <code>kmem_cache</code> 缓存中，该缓存内的内存块大小都为 BUF_SIZE 大小。随后内核再次分配一块同样大小的内存块，其会将刚释放的这块内存块分配出去。</p>
<h3 id="43-linux">4.3  Linux 设备及设备驱动</h3>
<p>在 Linux 中 <code>/dev</code> 目录下，存在很多设备文件，其中有一个 <code>/dev/ptmx</code>设备，这个设备文件主要用于打开一对伪终端设备，本次实验利用该设备进行控制流的劫持。</p>
<p>可能需要的头文件：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span><span class="c1"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="c1"> </span>
</code></pre></div></td></tr></table></div>
<h4 id="431-devptmx-tty_struct">4.3.1 /dev/ptmx 伪终端和 tty_struct 结构的利用</h4>
<p>进程打开 <code>/dev/ptmx</code> 设备可以通过使用代码 <code>open("/dev/ptmx", O_RDWR | O_NOCTTY)</code> 打开，当我们执行该代码时，内核会通过以下函数调用链，分配一个 <code>tty_struct</code> 结构体：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">ptmx_open</span><span class="w"> </span><span class="p">(</span><span class="n">drivers</span><span class="o">/</span><span class="n">tty</span><span class="o">/</span><span class="n">pty</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
<span class="o">-&gt;</span><span class="w"> </span><span class="n">tty_init_dev</span><span class="w"> </span><span class="p">(</span><span class="n">drivers</span><span class="o">/</span><span class="n">tty</span><span class="o">/</span><span class="n">tty_io</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">alloc_tty_struct</span><span class="w"> </span><span class="p">(</span><span class="n">drivers</span><span class="o">/</span><span class="n">tty</span><span class="o">/</span><span class="n">tty_io</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<p><code>tty_struct</code> 的结构可以<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/tty.h#L143">参考链接</a>所示,在5.15版本的内核中，其大小为 <code>0x2B8</code>(696字节) 大小。</p>
<p>其中第5个字段为 <code>const struct tty_operations *ops</code>,结构体 <code>tty_operations</code>可<a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/tty_driver.h#L247">参考链接</a>，该结构体实际上是多个函数指针的集合。在打开了设备终端之后，可以通过系统调用，调用该结构体中的函数，下面代码给了一个使用设备的 demo :</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="p">...</span><span class="w"> </span><span class="c1">//some head file &amp;&amp; main struct</span>
<span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/ptmx&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">O_NOCTTY</span><span class="p">);</span><span class="w"> </span><span class="c1">//open a dev</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// read err</span>
<span class="p">}</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// write err</span>
<span class="p">}</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// ioctl err</span>
<span class="p">}</span>
<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<h4 id="432-ioctl">4.3.2 利用 ioctl 控制寄存器</h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>`tty_operations` 结构体中有一个 ioctl 函数，其第一个参数为所对应终端设备的 tty_struct 结构体指针，第二个参数和第三个参数分别是 命令号(cmd) 和 参数所在地址(arg) 如下所示：
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tty</span><span class="p">,</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>同时用户态程序中 ioctl 系统调用函数原型和调用方式如下所示：
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">//函数原型：</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ioctl</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">__fd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__request</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="c1">//调用方式：</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>可以发现用户态调用 ioctl 时会将 cmd 和 arg 两个参数原封不动地传递给内核中的 ioctl，而 ARM64 架构下函数调用的参数存放在 x0, x1, x2...... 寄存器中，于是我们可以通过修改用户态 ioctl 的参数，从而控制 x1, x2 两个寄存器，并利用这两个寄存器和内核中一些 gadget，可以进而控制更多的寄存器，从而便可以构造函数的参数进行调用。例如：假如内核中存在`mov x1, x0` 的代码片段，由于 x1 寄存器是我们所控制的，而执行该代码片段之后，x0 寄存器内容我们也可以控制。
</code></pre></div></td></tr></table></div>
<p>为了控制ioctl函数，如果我们能够控制其所在结构体 <code>tty_operation</code>,或者构造一个假的 <code>tty_operation</code> 结构体，并控制 <code>tty_struct</code>结构体，将其中 <code>tty_operation</code> 成员对应的指针篡改成我们构造的假的结构体地址，这样当我们在用户态执行 <code>ioctl</code> 函数时，便可以跳转执行到我们想要执行的地址。</p>
<h3 id="44-jop">4.4 JOP 基础</h3>
<p>JOP(<a href="https://www.comp.nus.edu.sg/~liangzk/papers/asiaccs11.pdf">参考论文</a> ) 攻击是类似ROP攻击的一种，只不过ROP通过在栈上构造返回地址来形成攻击链，而JOP攻击不需要利用栈，可以使用跳转的方式来进行攻击，x86 下是通过 <code>jmp</code> 指令(<a href="https://www.anquanke.com/post/id/151571">参考链接</a>)，ARM 上通过 <code>BR/BLR</code> 指令(<a href="https://developer.arm.com/documentation/102433/0100/Jump-oriented-programming">参考链接</a>)。当JOP跳转的指令以 ret 指令结尾，其也能转化成 ROP 攻击。</p>
<h3 id="45-cred-root">4.5 利用 cred 结构体获取 root 权限</h3>
<p>从 user 获取 root 权限的方式有很多，本实验涉及利用 cred 结构体获取 root 权限的方式，更多方式可以参考 <a href="https://github.com/xairy/linux-kernel-exploitation">github项目</a> 或者浏览器搜索引擎搜索关键字 <code>linux kernel exploitation</code> 进行了解。</p>
<h4 id="451-struct-cred">4.5.1 struct cred的作用</h4>
<p>linux kernel 记录了每一个进程的权限，是用 <a href="https://elixir.bootlin.com/linux/v5.15/source/include/linux/cred.h#L110">cred</a> 结构体记录的，每个进程中都有一个 cred 结构，（ Linux 用 task_struct 结构来管理每个进程，该结构体中有个 cred 类型的指针成员）这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。</p>
<p>所以如果能够获取到当前进程的 task_struct 结构的地址，并通过偏移获取到相应的 cred_struct 的地址，就可以通过直接修改内存的方式，将 cred 中的 uid 和 gid 等字段都设置成0，从而当前进程即变成了 root 权限。此种方式较为困难但是可行，学生可以自行尝试。</p>
<p>同时在kernel有两个函数可以很方便地修改进程的权限：</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/v5.15/source/kernel/cred.c#L718">struct cred* prepare_kernel_cred(struct task_struct* daemon)</a></li>
<li><a href="https://elixir.bootlin.com/linux/v5.15/source/kernel/cred.c#L447">int commit_creds(struct cred *new)</a></li>
</ul>
<p>当给 <code>prepare_kernel_cred()</code> 函数传递一个NULL参数时，该函数会构造一个 kernel 权限的 cred 结构体，即 uid=0，gid=0，并返回该结构体地址。随后可以把该结构体地址作为参数传给 <code>commit_creds</code> 函数,即 <code>commit_creds(prepare_kernel_cred(0))</code>，这样就可以把当前进程的权限改为 root 权限。</p>
<h2 id="5">5 实验介绍</h2>
<p>本次实验虚拟机内提供的文件：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code>user@user-Super-Server:~/Desktop/experiment$ tree
.
├── qemu.sh
├── rootfs.img
└── vmlinux

0 directories, 3 files
</code></pre></div></td></tr></table></div>
<p>其中 qemu.sh 是运行 qemu 的脚本，rootfs.img 为文件系统镜像，vmlinux 为未压缩的内核。可以利用 gdb-multiarch 和 qemu 对vmlinux 进行调试。</p>
<p>同时提供了有 BUG 的设备驱动代码，同学们可以自行查看。</p>
<h3 id="51">5.1 实验环境搭建</h3>
<p>通过浙大云盘<a href="https://pan.zju.edu.cn/share/020138858d0479ba0a1906893b">链接</a>下载本次实验压缩包，并解压到lab1的 virtual box 实验镜像中。</p>
<p>解压之后路径如下</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code>syssec@VM:~/lab2$<span class="w"> </span>tree
.
├──<span class="w"> </span>kernel
│<span class="w">   </span>├──<span class="w"> </span>cfi
│<span class="w">   </span>│<span class="w">   </span>├──<span class="w"> </span>Image
│<span class="w">   </span>│<span class="w">   </span>├──<span class="w"> </span>System.map
│<span class="w">   </span>│<span class="w">   </span>├──<span class="w"> </span>uafdriver.c
│<span class="w">   </span>│<span class="w">   </span>└──<span class="w"> </span>vmlinux
│<span class="w">   </span>└──<span class="w"> </span>nocfi
│<span class="w">       </span>├──<span class="w"> </span>drivers
│<span class="w">       </span>│<span class="w">   </span>└──<span class="w"> </span>misc
│<span class="w">       </span>│<span class="w">       </span>└──<span class="w"> </span>uafdriver.c
│<span class="w">       </span>├──<span class="w"> </span>Image
│<span class="w">       </span>├──<span class="w"> </span>System.map
│<span class="w">       </span>└──<span class="w"> </span>vmlinux
├──<span class="w"> </span>qemu.sh
└──<span class="w"> </span>rootfs.img

<span class="m">5</span><span class="w"> </span>directories,<span class="w"> </span><span class="m">10</span><span class="w"> </span>files
</code></pre></div></td></tr></table></div>
<p>主要实验在 <code>nocfi</code> 文件夹中进行。其中 <code>uafdriver.c</code> 为包含 UAF bug 的驱动文件，可以通过查看其源码理解 UAF 漏洞原理。</p>
<blockquote>
<p>注意⚠️：<strong>本次实验环境既没有KASLR也没有SMAP防护</strong></p>
</blockquote>
<p>我们提供了编译好的内核镜像(Image)和gdb调试用的vmlinux（symbol可能会有问题）。也可以尝试自己将 <code>uafdriver.c</code> 驱动放到lab1所在的内核源码中(<code>drivers/misc/</code> 路径下)，再修改同文件夹下的 <code>Makefile</code>，增加一行</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">obj</span><span class="o">-</span><span class="n">y</span><span class="w">          </span><span class="o">+=</span><span class="w">      </span><span class="n">uafdriver</span><span class="p">.</span><span class="n">o</span>
</code></pre></div></td></tr></table></div>
<p>然后重新交叉编译内核源码即可。
（这样能够方便gdb调试，看到执行流和对应的c代码，直接运行 qemu 脚本也是可以的）</p>
<p>直接运行 qemu 脚本，并输入用户名与密码进入实验环境，可以在 qemu 虚拟机内部直接通过vim编写PoC，并通过gcc进行编译，gdb进行调试。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>sh<span class="w"> </span>qemu.sh

username：ubuntu
password：123
</code></pre></div></td></tr></table></div>
<h3 id="52-zjudev">5.2 zjudev接口</h3>
<p>本实验在 <code>/dev/</code>目录下提供一个 <code>zjudev</code> 的设备，该设备在内核维护一个结构体作为字符设备缓冲区，设备缓冲区如下所示，其中 <code>dev_buf</code> 字段为打开的设备分配缓冲区，<code>buf_len</code> 字段为缓冲区大小（为了防止缓冲区溢出，实际只能使用 <code>buf_len - 1</code>）：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">zjudev_struct</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dev_buf</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buf_len</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">zjudev</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p>同时该设备向用户暴露了几个关键接口：</p>
<ul>
<li>
<p><strong>open</strong>：</p>
</li>
<li>
<p>功能：打开 <code>zjudev</code> 设备，在内核中为该设备分配64字节的缓冲区大小。</p>
</li>
<li>
<p>用户态使用范例：</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/zjudev&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span><span class="w"> </span><span class="c1">//打开设备，权限为read/write，并返回fd作为文件句柄。（linux万物皆文件）</span>
</code></pre></div></td></tr></table></div>
* <strong>read</strong>：</p>
</li>
<li>
<p>功能：读取内核缓冲区中规定长度的内容，但是长度小于 <code>buf_len</code>。</p>
</li>
<li>
<p>用户态使用范例：</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
<span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">);</span><span class="c1">//从设备中读取40字节到buf字符数组中</span>
</code></pre></div></td></tr></table></div>
* <strong>write</strong>：</p>
</li>
<li>
<p>功能：写入一定长度的内容到内核缓冲区中，但长度不能超过内核缓冲区大小。</p>
</li>
<li>
<p>用户态使用范例：</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello, world!&quot;</span><span class="p">;</span>
<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span><span class="w"> </span><span class="c1">//将buf数组的内容写入设备缓冲区</span>
</code></pre></div></td></tr></table></div>
* <strong>ioctl</strong>:</p>
</li>
<li>
<p>功能：利用命令控制设备，本实验提供命令号为 <code>0x0001</code> 的命令，该功能为释放内核缓冲区，并重新分配一个要求大小的缓冲区，但是该缓冲区大小不能超过8K字节。</p>
</li>
<li>
<p>用户态使用范例：</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0001</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">);</span><span class="w"> </span><span class="c1">//其中0x0001为命令号，BUF_SIZE为要求的内核缓冲区大小。</span>
</code></pre></div></td></tr></table></div>
* <strong>close</strong>:</p>
</li>
<li>
<p>功能:关闭该设备，释放内核缓冲区。</p>
</li>
<li>
<p>用户态使用范例：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"> </span><span class="c1">//通过close系统调用关闭文件句柄。</span>
</code></pre></div></td></tr></table></div>
</li>
</ul>
<blockquote>
<p>我们代码中写了有printk打印，但其可能并不会被直接打印显示，解决办法有两种</p>
<ul>
<li>使用dmesg命令查看</li>
<li>如果你~~财力~~时间~~雄厚~~充足，可以给printk加入诸如KERN_EMERG/ALERT的参数然后重新编译kernel才能在命令行直接显示printk的消息：  <code>printk(KERN_EMERG “halo~~\n”);</code></li>
</ul>
</blockquote>
<h3 id="53-uaf">5.3 UAF漏洞介绍</h3>
<p>由于内核中该设备只有全局一个缓冲区，如果将设备打开两次，第二次打开的设备会覆盖第一次打开设备的缓冲区，且两次打开设备时候，我们可以获得指向同一个设备缓冲区的两个指针。此时如果释放其中一个设备，由于在释放的时候指针没有置空，此时便可以通过另一个文件描述符操作该缓冲区对应的内存，即存在 UAF 漏洞。</p>
<p>同时实验提供的 ioctl 接口能够调整这个缓冲区大小如果将其调整成内核中某个数据结构的大小，当内核分配相同大小的数据结构时，便会使用这块由我们控制的缓冲区，由此我们便可以控制内核的关键数据结构，最终达到 root 权限的目的。</p>
<h3 id="54-struct">5.4 struct结构介绍</h3>
<p><code>tty_struct</code>：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* offset    |  size */</span><span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_struct</span><span class="w"> </span><span class="p">{</span>
<span class="cm">/*    0      |     4 */</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">magic</span><span class="p">;</span>
<span class="cm">/*    4      |     4 */</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kref</span><span class="w"> </span><span class="p">{</span>
<span class="cm">/*    4      |     4 */</span><span class="w">        </span><span class="n">refcount_t</span><span class="w"> </span><span class="n">refcount</span><span class="p">;</span>

<span class="w">                               </span><span class="cm">/* total size (bytes):    4 */</span>
<span class="w">                           </span><span class="p">}</span><span class="w"> </span><span class="n">kref</span><span class="p">;</span>
<span class="cm">/*    8      |     8 */</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="cm">/*   16      |     8 */</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_driver</span><span class="w"> </span><span class="o">*</span><span class="n">driver</span><span class="p">;</span>
<span class="cm">/*   24      |     8 */</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_operations</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="cm">/*   32      |     4 */</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="cm">/* XXX  4-byte hole  */</span>
<span class="cm">/*   40      |    48 */</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ld_semaphore</span><span class="w"> </span><span class="p">{</span>
<span class="cm">/*   40      |     8 */</span><span class="w">        </span><span class="n">atomic_long_t</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="cm">/*   48      |     4 */</span><span class="w">        </span><span class="n">raw_spinlock_t</span><span class="w"> </span><span class="n">wait_lock</span><span class="p">;</span>
<span class="cm">/*   52      |     4 */</span><span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wait_readers</span><span class="p">;</span>
<span class="cm">/*   56      |    16 */</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="p">{</span>
<span class="cm">/*   56      |     8 */</span><span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="cm">/*   64      |     8 */</span><span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>

<span class="w">                                   </span><span class="cm">/* total size (bytes):   16 */</span>
<span class="w">                               </span><span class="p">}</span><span class="w"> </span><span class="n">read_wait</span><span class="p">;</span>
<span class="cm">/*   72      |    16 */</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="p">{</span>
<span class="cm">/*   72      |     8 */</span><span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="cm">/*   80      |     8 */</span><span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>

<span class="w">                                   </span><span class="cm">/* total size (bytes):   16 */</span>
<span class="w">                               </span><span class="p">}</span><span class="w"> </span><span class="n">write_wait</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></td></tr></table></div>
<h2 id="6">6 实验任务</h2>
<p>本次实验分为三个小任务，每个小任务难度逐层递进，实验最终要求是获取 root 权限下可读文件中的 flag，并写入自己的实验报告中提交。<strong>本次实验可能会涉及 ASLR，为了简化实验，本次实验提供了 gdb 和 System.map 文件，可以间接绕过。</strong></p>
<h3 id="61-task1">6.1 Task1：设备接口的使用。</h3>
<ul>
<li>编写程序，尝试使用设备接口。</li>
<li>尝试利用<strong>章节5.2</strong>的介绍触发 UAF 漏洞，并利用<strong>章节4.4</strong>所提的 <code>/dev/ptmx</code>设备(打开该设备内核会分配一个 <code>tty_struct</code>结构体, 但是因为 Linux 多核的关系，可能需要堆喷技术，多次打开结构体，多次分配，直到分配到我们UAF指针所控制的那块内存空间为止)，尝试控制一个 <code>tty_struct</code> 结构体，并且能够读取和修改所控制的 <code>tty_struct</code> 结构体的内容。（触发过程可能会造成 kernel crash，重启 qemu 即可）。</li>
</ul>
<blockquote>
<p>提示🌟：同一个设备符被close之后就不要再使用read等函数了。这里需要想办法保证在能够close的情况下，继续读取，该怎么做呢？</p>
<p>Question 2：如何确定自己所控制的指针一定被分配给 tty_struct结构体 ?</p>
<p>提示：tty_struct 结构体里有些字段比较特殊。</p>
</blockquote>
<h3 id="62-task2root-shell">6.2 Task2：简单获取root shell</h3>
<p>为了方便同学们获得 root 权限的 shell，本实验在内核中提供一个预先设置的函数 <code>hack_cred</code>，其定义如下所示，可以直接利用<strong>章节4.4</strong>所提的 <code>/dev/ptmx</code>设备,想办法劫持控制流，使其运行该函数获取 root 权限。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">hack_cred</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">tty_struct</span><span class="w"> </span><span class="o">*</span><span class="n">tty</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cred</span><span class="w"> </span><span class="o">*</span><span class="n">root_cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">commit_creds</span><span class="p">(</span><span class="n">root_cred</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>具体步骤如下：</p>
<ul>
<li>利用 gdb-multiarch 调试 kernel，获取该函数地址。</li>
<li>根据前述知识和 <code>/dev/ptmx</code> 设备，将 <code>/dev/zjudev</code> 设备的缓冲区修改为 <code>tty_struct</code>结构体大小，并想办法控制该结构体，读取该结构内字段。</li>
<li>利用 <code>write</code> 系统调用控制该结构体内 <code>tty_operation</code> 成员，并将其中某个函数指针地址修改为 <code>hack_cred</code> 的地址</li>
<li>利用系统调用触发该函数，形成一次跳转的JOP攻击</li>
</ul>
<blockquote>
<p>提示🌟：这里没有开启smap保护，所以内核可以访问用户态的内存</p>
<p>Question 3: 为什么不能直接通过 UAF 控制 cred 结构体直接修改其内容？有没有办法能够通过 UAF 来利用新版本的 cred 结构体呢？</p>
<p>提示：prepare_kernel_cred 函数源码，以及 linux 内核堆内存分配器机制。</p>
</blockquote>
<h3 id="63-task3gadget-root-shell">6.3 Task3：gadget 获取 root shell</h3>
<p>第三个小任务在第二个任务的基础上增加了一点难度，要求不使用我们提供的 <code>hack_cred</code> 函数，而是使用零碎的以 <code>br/blr</code> 指令结尾的汇编代码片段（称为gadget）实现获取root权限。</p>
<p>为了降低实验难度，我们提供了三个gadget (可以利用工具自行在内核镜像中寻找可利用的代码片段) ，如下所示。利用这三个 gadget 以及前述知识，修改我们所控制的 <code>tty_struct</code> 和 <code>tty_operation</code> 结构体的内容，并多次使用 <code>tty_operation</code> 接口获取一些信息，并最终获得root权限。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">zju_gadget1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="w"> </span><span class="p">(</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;ldr x1, [x0, #0x38]     </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;mov x0,x2     </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;br x1 </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">zju_gadget2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="w"> </span><span class="p">(</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;mov x0,0     </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;ldr x1, [x2, #0x28]     </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="s">&quot;br x1 </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">zju_gadget3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="w"> </span><span class="p">(</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;ret     </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>具体步骤如下：</p>
<ul>
<li>利用 gdb-multiarch 获取三个gadget代码片段地址，以及 <code>prepare_kernel_cred</code> 和 <code>commit_creds</code> 函数地址。</li>
<li>利用 <code>zju_gadget3</code>，获取 <code>tty_struct</code> 结构体的地址。（注意：返回的结构体地址为 x0 寄存器的内容，但是会和真实值不一样，找到原因并获取真实的结构体地址）</li>
<li>利用剩下两个gadget控制寄存器 x0，x1，x2，并想办法设置tty operations构造 0 参数，跳转执行 <code>prepare_kernel_cred</code> 函数，获取其返回地址。</li>
<li>利用剩下两个gadget控制寄存器 x0，x1，x2，并想办法将x0寄存器的值控制成上一步所获得的cred的地址，并调用 <code>commit_creds</code> 函数。</li>
<li>获取 root shell 之后读取flag文件。</li>
</ul>
<blockquote>
<p>提示🌟：不要忘了ioctl的参数类型(fd, int, arg)</p>
<p>Question 4:为什么第二步可以直接ret获取到 <code>tty_struct</code>结构体的地址？ret 执行前后的控制流是什么样的？</p>
</blockquote>
<h3 id="64-task4-cfi">6.4 Task4: 内核 CFI 保护</h3>
<p>为了抵御上述劫持内核控制流的JOP攻击，安全研究人员提出了控制流完整性的保护方案（<a href="https://lwn.net/Articles/810077/">Control-Flow Integrity</a>）。目前内核支持匹配函数类型的CFI保护，需要利用 Clang/LLVM 编译器编译内核源码，最后得到支持CFI的内核镜像。对于每个间接调用，编译器通过匹配其函数指针和函数的类型，提前计算出潜在的目标函数集合，生成跳转表，限制间接调用的目标函数必须在集合中。</p>
<p>实验内容如下：</p>
<ul>
<li>使用objdump反汇编开启CFI的内核镜像 <code>vmlinux</code>，获得汇编代码，<strong>提交任意一个间接调用的汇编代码</strong>，并详细解释CFI是如何防御JOP攻击。</li>
<li>重新运行JOP攻击程序，查看是否CFI是否能起作用。<strong>提交dmesg中包含CFI Failure截图</strong>。</li>
</ul>
<h2 id="7">7. 实验提交</h2>
<p>请同学们在学在浙大上提交实验报告。格式要求为 pdf，命名为学号+姓名+ lab2.pdf。实验报告需要包含以下内容：</p>
<ul>
<li>flag 文件的内容</li>
<li>Task2 和 Task3 的 PoC 代码</li>
<li>Task4 中要求提交的内容</li>
<li>回答Question1~4</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.top"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.f1b6f286.min.js"></script>
      
    
  </body>
</html>